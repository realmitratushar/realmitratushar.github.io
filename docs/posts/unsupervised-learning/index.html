<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.189">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Neil Dcruze">
<meta name="dcterms.date" content="2023-03-31">
<meta name="description" content="Image Compression using Singular Value Decomposition">

<title>Unsupervised Learning with Linear Algebra</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html">Home</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html">Blog</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../project.html">Projects</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../work.html">Work</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cv.pdf">CV</a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Unsupervised Learning with Linear Algebra</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Machine Learning</div>
  </div>
  </div>

<div>
  <div class="description">
    Image Compression using Singular Value Decomposition
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Neil Dcruze </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">March 31, 2023</p>
    </div>
  </div>
    
  </div>
  

</header>

<section id="introduction-to-singular-value-decomposition-svd" class="level1">
<h1>Introduction to Singular Value Decomposition (SVD)</h1>
<p>In one of our lectures, we discussed the concept of <i>matrix factorization</i> methods - where we decompose a matrix into two or more simpler matrices. This is an example of <i>dimensionality reduction</i>, and these simpler matrices allow us to capture the underlying structure and relationships within the data.</p>
Previously, we have discussed Principal Component Analysis (PCA) and Nonnegative Matrix Factorization (NMF) as matrix factorization methods. However, for this blog post we will be looking at: <i>Singular Value Decomposition</i> (SVD). A SVD of a real matrix <span class="math inline">\(A \in \mathbb{R}^{m \times n}\)</span> is:<br><br> <span class="math display">\[
A = UDV^{T}
\]</span> In this decomposition:
<ol>
<li>
D: <span class="math inline">\(D \in \mathbb{R}^{m \times n} \rightarrow\)</span> whose diagonal contains singular values <span class="math inline">\(\sigma_i\)</span> of <span class="math inline">\(A\)</span>. The singular values quantify the importance of each singular vector in capturing the underlying structure and variations in the data. Larger singular values indicate more significant contributions to the data’s variation, while smaller singular values represent less significant contributions.
</li><li>
U: <span class="math inline">\(U \in \mathbb{R}^{m \times m} \rightarrow \text{Orthogonal Matrix}\)</span>
</li><li>
V: <span class="math inline">\(V \in \mathbb{R}^{n \times n} \rightarrow \text{Orthogonal Matrix}\)</span>
</li></ol>
</section>
<section id="matrix-approximation-using-svd" class="level1">
<h1>Matrix Approximation using SVD</h1>
In this section of the blog post, we aim to:
<ol>
<li>
Get acquainted with <i>numpy’s</i> implementation of SVD
</li><li>
Develop an appreciation of how SVD allows us to approximate a matrix <span class="math inline">\(A\)</span> using much smaller representations of matrices
</li></ol>
<section id="getting-acquainted-with-numpys-implementation-of-svd" class="level4">
<h4 class="anchored" data-anchor-id="getting-acquainted-with-numpys-implementation-of-svd"><font color="green">Getting Acquainted with <i>Numpy’s</i> Implementation of SVD</font></h4>
<p>Before we decompose a matrix <span class="math inline">\(A\)</span> using SVD, we need to construct a sample matrix <span class="math inline">\(A\)</span>:</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pyplot <span class="im">as</span> plt</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">12345</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>a1 <span class="op">=</span> np.random.randint(<span class="dv">1</span>, <span class="dv">3</span>, (<span class="dv">5</span>, <span class="dv">4</span>))</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>a2 <span class="op">=</span> np.random.randint(<span class="dv">1</span>, <span class="dv">3</span>, (<span class="dv">4</span>, <span class="dv">8</span>))</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">#constructing our sample matrix A</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> a1<span class="op">@</span>a2 <span class="op">+</span> <span class="fl">0.1</span><span class="op">*</span>np.random.rand(<span class="dv">5</span>, <span class="dv">8</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, we can go ahead and visualize this matrix:</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>A</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>array([[11.09940146, 11.06768737, 12.07908225, 14.01709143, 14.00268493,
        11.08003702, 10.09037225, 11.00246762],
       [ 7.04917473,  8.05262552,  9.0596366 , 10.00519575, 10.08950895,
         8.07282662,  7.081835  ,  8.05002228],
       [11.08101894, 10.00959685, 12.021895  , 14.02587191, 14.04681058,
        10.04593732, 11.07095098, 10.0178053 ],
       [ 9.05314499, 10.01677422, 11.07688139, 12.09281705, 12.06094937,
         9.01501835,  8.04896267, 10.0377345 ],
       [10.08486014, 11.09110972, 13.03838487, 14.03154959, 14.05683942,
        10.0187818 , 10.01258415, 11.06875958]])</code></pre>
</div>
</div>
<p>With matrices, it is often of utility to visualize them as an image to get an understanding of the underlying pattern:</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>plt.imshow(A, cmap <span class="op">=</span> <span class="st">"Greys"</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> plt.gca().axis(<span class="st">"off"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-4-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Now that we have our matrix <span class="math inline">\(A\)</span>, we can use <i>numpy’s</i> implementation of SVD, to get <span class="math inline">\(U\)</span>, <span class="math inline">\(V\)</span>, and <i>sigma</i> which has been discussed above. The only difference is that we get <i>sigma</i> and not <span class="math inline">\(D\)</span>. This means that we get a numpy array of the singular values of <span class="math inline">\(A\)</span>, but we have to construct a diagonal matrix - <span class="math inline">\(D\)</span> - ourselves, where the diagonals contain the singular values of <span class="math inline">\(A\)</span>. We can wrap up all of these functionalities in a single <code>getValues</code> function, which will call the <code>diagonalize</code> function to create the matrix <span class="math inline">\(D\)</span> out of <i>sigma</i>:</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> getValues(matrix):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    U, sigma, V <span class="op">=</span> np.linalg.svd(matrix)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    D <span class="op">=</span> diagonalize(matrix, sigma)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U, D, V</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> diagonalize(matrix, sigma):</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># creating the D matrix in the SVD </span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># here the matrix of 0s will have the same shape as A</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    D <span class="op">=</span> np.zeros_like(matrix, dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># putting the singular values along the diagonal of D</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    D[:<span class="bu">min</span>(matrix.shape),:<span class="bu">min</span>(matrix.shape)] <span class="op">=</span> np.diag(sigma)  </span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> D</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>U, D, V <span class="op">=</span> getValues(A)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, let us try to reconstruct <span class="math inline">\(A\)</span> using the decomposed matrices as displayed in the formula above and compare it to the original <span class="math inline">\(A\)</span>:</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>U <span class="op">@</span> D <span class="op">@</span> V</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>array([[11.09940146, 11.06768737, 12.07908225, 14.01709143, 14.00268493,
        11.08003702, 10.09037225, 11.00246762],
       [ 7.04917473,  8.05262552,  9.0596366 , 10.00519575, 10.08950895,
         8.07282662,  7.081835  ,  8.05002228],
       [11.08101894, 10.00959685, 12.021895  , 14.02587191, 14.04681058,
        10.04593732, 11.07095098, 10.0178053 ],
       [ 9.05314499, 10.01677422, 11.07688139, 12.09281705, 12.06094937,
         9.01501835,  8.04896267, 10.0377345 ],
       [10.08486014, 11.09110972, 13.03838487, 14.03154959, 14.05683942,
        10.0187818 , 10.01258415, 11.06875958]])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>A</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>array([[11.09940146, 11.06768737, 12.07908225, 14.01709143, 14.00268493,
        11.08003702, 10.09037225, 11.00246762],
       [ 7.04917473,  8.05262552,  9.0596366 , 10.00519575, 10.08950895,
         8.07282662,  7.081835  ,  8.05002228],
       [11.08101894, 10.00959685, 12.021895  , 14.02587191, 14.04681058,
        10.04593732, 11.07095098, 10.0178053 ],
       [ 9.05314499, 10.01677422, 11.07688139, 12.09281705, 12.06094937,
         9.01501835,  8.04896267, 10.0377345 ],
       [10.08486014, 11.09110972, 13.03838487, 14.03154959, 14.05683942,
        10.0187818 , 10.01258415, 11.06875958]])</code></pre>
</div>
</div>
<p>They are the same!</p>
</section>
<section id="approximating-a-using-smaller-matrices" class="level4">
<h4 class="anchored" data-anchor-id="approximating-a-using-smaller-matrices"><font color="green">Approximating <span class="math inline">\(A\)</span> using Smaller Matrices</font></h4>
One of the main reasons why SVD is so useful is because we can get a pretty good approximation of the matrix <span class="math inline">\(A\)</span> by choosing a smaller subset of these decomposed matrices: <span class="math inline">\(U\)</span>, <span class="math inline">\(D\)</span>, and <span class="math inline">\(V\)</span>. For instance, in our original situation:<br><br> <span class="math display">\[
A = UDV^{T} = \{m \times m\} \times \{m \times n\} \times \{n \times n\} = \{m \times n\}
\]</span> <br>However, we can choose a subset say <span class="math inline">\(k\)</span> = 3, where we will only:
<ul>
<li>
Pick the first <span class="math inline">\(k\)</span> columns of U
</li><li>
Pick the top <span class="math inline">\(k\)</span> singular values of D
</li><li>
Pick the first <span class="math inline">\(k\)</span> rows of V
</li></ul>
<p>Which gives us:<br><br> <span class="math display">\[
A = UDV^{T} = \{m \times k\} \times \{k \times k\} \times \{k \times n\} = \{m \times n\}
\]</span> <br>Therefore, we can get a <span class="math inline">\(m \times n\)</span> approximation of <span class="math inline">\(A\)</span> using a smaller subset of these decomposed matrices. The way this works is that in SVD, the obtained singular values are present in decreasing order of “importance”. This means that the first singular value is typically the most important in terms of capturing the primary patterns, structures, and variations of the data, and this “importance” keeps on decreasing as we go down. Therefore, depending on our value of <span class="math inline">\(k\)</span>, we can get a pretty good approximation of the original matrix using a relatively smaller subset of the decomposed matrices. To see this in practice, let us create a function that will allow us to visualize our: original matrix <span class="math inline">\(A\)</span> and the reconstructed matrix <span class="math inline">\(A\)</span> with a smaller subset of the decomposed matrices, as images. This will allow us to get an appreciation of how similar the reconstructed matrix <span class="math inline">\(A\)</span> is to the original one, while saving us a lot of space because we used a smaller subset of the matrices:</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compareImages(A, A_):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    fig, axarr <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize <span class="op">=</span> (<span class="dv">15</span>, <span class="dv">5</span>))</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    axarr[<span class="dv">0</span>].imshow(A, cmap <span class="op">=</span> <span class="st">"Greys"</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    axarr[<span class="dv">0</span>].axis(<span class="st">"off"</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    axarr[<span class="dv">0</span>].<span class="bu">set</span>(title <span class="op">=</span> <span class="st">"Original Image"</span>)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    axarr[<span class="dv">1</span>].imshow(A_, cmap <span class="op">=</span> <span class="st">"Greys"</span>)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    axarr[<span class="dv">1</span>].axis(<span class="st">"off"</span>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    axarr[<span class="dv">1</span>].<span class="bu">set</span>(title <span class="op">=</span> <span class="st">"Reconstructed Image"</span>)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="co">#creating subsets of the decomposed matrices</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>U_ <span class="op">=</span> U[:,:k]</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>D_ <span class="op">=</span> D[:k, :k]</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>V_ <span class="op">=</span> V[:k, :]</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>A_ <span class="op">=</span> U_ <span class="op">@</span> D_ <span class="op">@</span> V_</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span class="co"># visualizing the original and reconstructed matrix A (images)</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>compareImages(A, A_)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-8-output-1.png" class="img-fluid"></p>
</div>
</div>
Therefore, we can see that our <i>reconstructed image</i> is pretty much the same as the original image, and we have reduced the size of our problem from:
<ol>
<li>
<span class="math inline">\(A_\text{original} = \{5 \times 8\} = 40 \text{ units}\)</span>, to
</li><li>
<span class="math inline">\(A_\text{reconstructed} = U_{\text{k}}D_{\text{k}}V_{\text{k}}^{T} = \{5 \times 1\} + \{1 \times 1\} + \{1 \times 8\} = 14 \text{ units}\)</span>
</li></ol>
</section>
</section>
<section id="image-compression-using-matrix-approximation" class="level1">
<h1>Image Compression using Matrix Approximation</h1>
Now that we have understood how using SVD, we can get a fairly good approximation of the matrix <span class="math inline">\(A\)</span> using a much smaller subset of the decomposed matrices, we can go ahead and apply to this to <i>image compression</i>. In simple words, what we are trying to do is:
<ol>
<li>
Represent an image as a matrix,
</li><li>
Decompose the matrix using SVD,
</li><li>
Use a smaller subset of these decomposed matrices to reconstruct the original image (matrix)
</li></ol>
For the purpose of this experiment, the chosen image is:
<center>
<figure class="figure">
<img src="spongebob.jpg" height="500" width="800" caption="Mr. Squarepants" class="figure-img">
<figcaption class="figure-caption">
SpongeBob SquarePants
</figcaption>
</figure>
</center>
<p>Now, let us get started:</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> PIL</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> urllib</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">#function to read an image and save it as a numpy array </span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> read_image(url):</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(PIL.Image.<span class="bu">open</span>(urllib.request.urlopen(url)))</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>url <span class="op">=</span> <span class="st">"https://i.pinimg.com/originals/1f/f9/68/1ff9682f61e99f217bb67a61f02ecb56.jpg"</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>img <span class="op">=</span> read_image(url)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>np.shape(img)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre><code>(1200, 1920, 3)</code></pre>
</div>
</div>
<p>Therefore, we can see that our image is stored as a numpy object of shape: <span class="math inline">\(1200 \times 1920 \times 3\)</span>, this means that there are <span class="math inline">\(1200\)</span> rows, <span class="math inline">\(1920\)</span> columns, and the <span class="math inline">\(3\)</span> is representative of the RGB channels - since at each pixel there is a numerical value for all red, green, and blue. To simplify our task of image compression using SVD, we want to deal with a 2-Dimensional matrix. To do this, we can convert this image to <i>greyscale</i> in which case it will have dimensions: <span class="math inline">\(1200 \times 1920\)</span> - <span class="math inline">\(1200\)</span> rows, <span class="math inline">\(1920\)</span> columns, and each value will range from <span class="math inline">\(0\)</span> to <span class="math inline">\(255\)</span>. Where, <span class="math inline">\(0\)</span> = Black, and <span class="math inline">\(255\)</span> = White. Converting our image to <i>greyscale</i>:</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> to_greyscale(image):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="op">-</span> np.dot(image[...,:<span class="dv">3</span>], [<span class="fl">0.2989</span>, <span class="fl">0.5870</span>, <span class="fl">0.1140</span>])</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>grey_img <span class="op">=</span> to_greyscale(img)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>np.shape(grey_img)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>(1200, 1920)</code></pre>
</div>
</div>
<p>As mentioned, the image is now a <span class="math inline">\(1200 \times 1920\)</span> matrix. Now, let us visualize the original and greyscale image side-by-side:</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>fig, axarr <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize <span class="op">=</span> (<span class="dv">15</span>, <span class="dv">5</span>))</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>axarr[<span class="dv">0</span>].imshow(img)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>axarr[<span class="dv">0</span>].axis(<span class="st">"off"</span>)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>axarr[<span class="dv">0</span>].<span class="bu">set</span>(title <span class="op">=</span> <span class="st">"Original Image"</span>)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>axarr[<span class="dv">1</span>].imshow(grey_img, cmap <span class="op">=</span> <span class="st">"Greys"</span>)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>axarr[<span class="dv">1</span>].axis(<span class="st">"off"</span>)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>axarr[<span class="dv">1</span>].<span class="bu">set</span>(title <span class="op">=</span> <span class="st">"Greyscale Image"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>[Text(0.5, 1.0, 'Greyscale Image')]</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-11-output-2.png" class="img-fluid"></p>
</div>
</div>
<section id="reconstructing-the-image-from-its-singular-value-decomposition" class="level4">
<h4 class="anchored" data-anchor-id="reconstructing-the-image-from-its-singular-value-decomposition"><font color="green">Reconstructing the Image from its Singular Value Decomposition</font></h4>
<p>Now, we will write the function <code>svd_reconstruct</code> which will reconstruct an image using <span class="math inline">\(k\)</span> singular values:</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> svd_reconstruct(image, k):</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    U, D, V <span class="op">=</span> getValues(image)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    U_ <span class="op">=</span> U[:,:k]</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    D_ <span class="op">=</span> D[:k, :k]</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    V_ <span class="op">=</span> V[:k, :]</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    grey_img_recon <span class="op">=</span> U_ <span class="op">@</span> D_ <span class="op">@</span> V_</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> grey_img_recon</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, we can go ahead and visualize how our reconstructed image would look with, let’s say, <span class="math inline">\(k = 50\)</span> singular values:</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>compareImages(grey_img, svd_reconstruct(grey_img, <span class="dv">50</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-13-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="experimenting-with-different-values-of-k" class="level4">
<h4 class="anchored" data-anchor-id="experimenting-with-different-values-of-k"><font color="green">Experimenting with Different Values of <span class="math inline">\(k\)</span></font></h4>
<p>In this, part of the code, we first want to modify our <code>svd_reconstruct</code> to incorporate the calculation of how much space we are saving for differing values of <span class="math inline">\(k\)</span>. The formula for this would be:<br><br> <span class="math display">\[
\text{Percent Storage} = \frac{\text{Storage Needed for Reconstructed}}{\text{Storage Needed for Original}} = \frac{\{(m \times k) + (k \times k) + (k \times n)\} \times 8 \text{ bits}}{m \times n \times 8 \text{ bits}}
\]</span></p>
<p><span class="math display">\[
= (\frac{mk + kk + kn}{mn}) \times 100
\]</span> <br>We know, that the matrix of our original image contains <span class="math inline">\(m \times n\)</span> values - each of which is 8 bytes, if we perform SVD and choose <span class="math inline">\(k\)</span> singular values, then we have <span class="math inline">\(mk + kk + kn\)</span> values - each of which is 8 bytes! Thus, the above formula represents the way in which we can achieve percent storage.</p>
<p><b><u>Note</u>: Percent Storage is a measure of what percentage of the original size is the reconstructed image using! So, % Storage = <span class="math inline">\(30\)</span>% means that the reconstructed image’s storage size is <span class="math inline">\(30\)</span>% of that of the original!</b></p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> svd_reconstruct(image, k):</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    U, D, V <span class="op">=</span> getValues(image)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    U_ <span class="op">=</span> U[:,:k]</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    D_ <span class="op">=</span> D[:k, :k]</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    V_ <span class="op">=</span> V[:k, :]</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    grey_img_recon <span class="op">=</span> U_ <span class="op">@</span> D_ <span class="op">@</span> V_</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">#code for calculating percent storage</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    reconstructedStorage <span class="op">=</span> (image.shape[<span class="dv">0</span>] <span class="op">*</span> k) <span class="op">+</span> (k <span class="op">*</span> k) <span class="op">+</span> (k <span class="op">*</span> image.shape[<span class="dv">1</span>])</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    originalStorage <span class="op">=</span> image.shape[<span class="dv">0</span>] <span class="op">*</span> image.shape[<span class="dv">1</span>]</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    percentStorage <span class="op">=</span> np.<span class="bu">round</span>((reconstructedStorage<span class="op">/</span>originalStorage) <span class="op">*</span> <span class="dv">100</span>, <span class="dv">2</span>)</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">#returning reconstructed image, and % storage</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> grey_img_recon, percentStorage</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, we want to write our <code>svd_experiment</code> function which will help us look at the effects that varying size of <span class="math inline">\(k\)</span> has on: the quality of the image, and the % storage:</p>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> svd_experiment(image):</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    rows <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    cols <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    fig, axarr <span class="op">=</span> plt.subplots(rows, cols, figsize <span class="op">=</span> (<span class="dv">25</span>, <span class="dv">10</span>))</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> [<span class="dv">13</span> <span class="op">*</span> i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">21</span>)]</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    index <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(rows):</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(cols):</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>            <span class="co">#using the value of k at a particular index and then incrementing</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>            reconstructedImg, perStorage <span class="op">=</span> svd_reconstruct(image, k[index])</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>            index<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>            <span class="co">#showing the reconstructed image</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>            axarr[i][j].imshow(reconstructedImg, cmap <span class="op">=</span> <span class="st">"Greys"</span>)</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>            axarr[i][j].axis(<span class="st">"off"</span>)</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>            axarr[i][j].<span class="bu">set</span>(title <span class="op">=</span> <span class="ss">f"k = </span><span class="sc">{</span>k[index<span class="op">-</span><span class="dv">1</span>]<span class="sc">}</span><span class="ss"> Singular Values, % Storage = </span><span class="sc">{</span>perStorage<span class="sc">}</span><span class="ss">%"</span>)</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>    fig.tight_layout()</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>svd_experiment(grey_img)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-15-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Therefore, we can see that as the number of <span class="math inline">\(k\)</span> decrease, the quality of the picture becomes blurrier, however the % storage falls. For example in our situation for <span class="math inline">\(k = 13\)</span>, the reconstructed image’s size is <span class="math inline">\(1.77\)</span>% of the original image. However, the quality of the image is really low.</p>
<p>To get an appreciation for SVD, we should realize that for around <span class="math inline">\(k = 104\)</span>, the reconstructed image becomes pretty similar to the original, but the reconstructed image only takes 14.55% the storage that the original one took!</p>
</section>
</section>
<section id="optional-extras" class="level1">
<h1>Optional Extras</h1>
In this section of the blog post, we want to modify our <code>svd_reconstruct</code> function to allow the user to:
<ol>
<li>
Specify a Desired Compression Factor and Select the Number of Components <span class="math inline">\(k\)</span> based on this Selection:<br><br> <span class="math display">\[
        \text{Compression Factor (CF)} = \frac{\text{Size of Compressed Bits}}{\text{Size of Original Bits}}
        \]</span> <span class="math display">\[
        \text{CF} =\frac{mk + k^{2} + kn}{mn} = \frac{k^2 + k(m+n)}{mn}
        \]</span> <span class="math display">\[
        k^2 + k(m+n) = (mn) \times \text{ CF}
        \]</span> <span class="math display">\[
        k^2 + k(m+n) - [(mn) \times \text{ CF}] = 0
        \]</span> Therefore, we can solve this quadratic equation and get the value for <span class="math inline">\(k\)</span>, for the user provided compression factor!<br><br>
</li><li>
Specify a Desired Threshold <i>epsilon</i> for the Singular Values: selecting all singular values <span class="math inline">\(i\)</span>, such that:<br><br> <span class="math display">\[
            \sigma_{i} \geq \epsilon_{\text{threshold}}
        \]</span>
</li></ol>
<p><b><u>Note</u>: The following implementation assumes that the user will either only specify the (1) <i>compression factor</i>, or only the (2) <i>epsilon factor</i>, or only the explicit value of (3) <i>k - Singular Values</i></b></p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> svd_reconstruct(image, k, cf <span class="op">=</span> <span class="dv">0</span>, epsilon <span class="op">=</span> <span class="dv">0</span>):</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    grey_img_recon <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># checking for when compression factor is specified</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(cf<span class="op">!=</span><span class="dv">0</span>):</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># specifying the coefficients of the quadratic equation</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> image.shape[<span class="dv">0</span>] <span class="op">+</span> image.shape[<span class="dv">1</span>]</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>        c <span class="op">=</span> (<span class="op">-</span><span class="dv">1</span>) <span class="op">*</span> cf  <span class="op">*</span> image.shape[<span class="dv">0</span>] <span class="op">*</span> image.shape[<span class="dv">1</span>]</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># only looking at the positive value - therefore ignoring the negative</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>        k <span class="op">=</span> (<span class="op">-</span>b <span class="op">+</span> np.sqrt((b<span class="op">*</span>b)<span class="op">-</span>(<span class="dv">4</span><span class="op">*</span>a<span class="op">*</span>c)))<span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>a)</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># rounding the value of k - since we can only have whole values - and converting to integer</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>        k <span class="op">=</span> np.<span class="bu">round</span>(k)</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>        k <span class="op">=</span> k.astype(<span class="bu">int</span>)</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># reconstructing our grey image, based on this value of k </span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>        U, D, V <span class="op">=</span> getValues(image)</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>        U_ <span class="op">=</span> U[:,:k]</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>        D_ <span class="op">=</span> D[:k, :k]</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>        V_ <span class="op">=</span> V[:k, :]</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>        grey_img_recon <span class="op">=</span> U_ <span class="op">@</span> D_ <span class="op">@</span> V_</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># checking for when epsilon value is specified</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span>(epsilon<span class="op">!=</span><span class="dv">0</span>):</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>        U, sigma, V <span class="op">=</span> np.linalg.svd(image)</span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># finding k - the number of singular values which are </span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>        <span class="co"># above epsilon - the specified threshold </span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>        k <span class="op">=</span> (sigma[sigma<span class="op">&gt;</span>epsilon]).size</span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>        D <span class="op">=</span> diagonalize(image, sigma)</span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>        <span class="co"># reconstructing our grey image, based on this value of k </span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>        U_ <span class="op">=</span> U[:,:k]</span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>        D_ <span class="op">=</span> D[:k, :k]</span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>        V_ <span class="op">=</span> V[:k, :]</span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>        grey_img_recon <span class="op">=</span> U_ <span class="op">@</span> D_ <span class="op">@</span> V_</span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># checking for default case when only </span></span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span>(epsilon<span class="op">==</span><span class="dv">0</span> <span class="kw">and</span> cf<span class="op">==</span><span class="dv">0</span>):</span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>        U, D, V <span class="op">=</span> getValues(image)</span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>        U_ <span class="op">=</span> U[:,:k]</span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>        D_ <span class="op">=</span> D[:k, :k]</span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a>        V_ <span class="op">=</span> V[:k, :]</span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a>        grey_img_recon <span class="op">=</span> U_ <span class="op">@</span> D_ <span class="op">@</span> V_</span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">#code for calculating percent storage</span></span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a>    reconstructedStorage <span class="op">=</span> (image.shape[<span class="dv">0</span>] <span class="op">*</span> k) <span class="op">+</span> (k <span class="op">*</span> k) <span class="op">+</span> (k <span class="op">*</span> image.shape[<span class="dv">1</span>])</span>
<span id="cb21-45"><a href="#cb21-45" aria-hidden="true" tabindex="-1"></a>    originalStorage <span class="op">=</span> image.shape[<span class="dv">0</span>] <span class="op">*</span> image.shape[<span class="dv">1</span>]</span>
<span id="cb21-46"><a href="#cb21-46" aria-hidden="true" tabindex="-1"></a>    percentStorage <span class="op">=</span> np.<span class="bu">round</span>((reconstructedStorage<span class="op">/</span>originalStorage) <span class="op">*</span> <span class="dv">100</span>, <span class="dv">2</span>)</span>
<span id="cb21-47"><a href="#cb21-47" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-48"><a href="#cb21-48" aria-hidden="true" tabindex="-1"></a>    <span class="co">#returning reconstructed image, and % storage</span></span>
<span id="cb21-49"><a href="#cb21-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> grey_img_recon, percentStorage</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="experiments-with-different-values-of-compression-factor" class="level4">
<h4 class="anchored" data-anchor-id="experiments-with-different-values-of-compression-factor"><font color="green">Experiments with Different Values of Compression Factor</font></h4>
<p>Now, we can go ahead get a reconstructed image with a compression factor of say <span class="math inline">\(0.05\)</span>! This means that the reconstructed image, will be <span class="math inline">\(0.05 * 100 = 5\)</span>% of the storage of the actual image:</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>reconstructedImage, perStorage <span class="op">=</span> svd_reconstruct(grey_img, <span class="dv">0</span>, <span class="fl">0.05</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>compareImages(grey_img, reconstructedImage)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-17-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Now, we can go ahead get a reconstructed image with a compression factor of say <span class="math inline">\(0.3\)</span>! This means that the reconstructed image, will be <span class="math inline">\(0.3 * 100 = 30\)</span>% of the storage of the actual image:</p>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>reconstructedImage, perStorage <span class="op">=</span> svd_reconstruct(grey_img, <span class="dv">0</span>, <span class="fl">0.3</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>compareImages(grey_img, reconstructedImage)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-18-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Therefore, we can see that as the compression factor goes up, the reconstructed image becomes more like the original image!</p>
</section>
<section id="experiments-with-different-values-of-epsilon---epsilon" class="level4">
<h4 class="anchored" data-anchor-id="experiments-with-different-values-of-epsilon---epsilon"><font color="green">Experiments with Different Values of Epsilon - <span class="math inline">\(\epsilon\)</span></font></h4>
<p>Finally, we can experiment providing an <span class="math inline">\(\epsilon\)</span> - epsilon value, which provides a threshold and only the singular values larger than this specified value will be selected. Let us say, we choose <span class="math inline">\(\epsilon = 13000\)</span> as our threshold. Therefore, only the singular values which are larger than <span class="math inline">\(13000\)</span> will be used in the image reconstruction:</p>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>reconstructedImage, perStorage <span class="op">=</span> svd_reconstruct(grey_img, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">13000</span>)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>compareImages(grey_img, reconstructedImage)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-19-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Let us say, we choose <span class="math inline">\(\epsilon = 130\)</span> as our threshold. Therefore, only the singular values which are larger than <span class="math inline">\(130\)</span> will be used in the image reconstruction:</p>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>reconstructedImage, perStorage <span class="op">=</span> svd_reconstruct(grey_img, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">130</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>compareImages(grey_img, reconstructedImage)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-20-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Therefore, we can see that as our threshold for the singular values goes down, more and more singular values are used in the image reconstruction, and therefore the reconstructed image becomes more like the original!</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>